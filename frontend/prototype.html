<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>Gemini TTS 语音播放 Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Microsoft Yahei', sans-serif; padding: 24px; }
    .row { margin-bottom: 12px; }
    label { display: block; font-size: 14px; color: #555; margin-bottom: 6px; }
    input[type="password"], textarea { width: 100%; box-sizing: border-box; padding: 8px; border: 1px solid #ccc; border-radius: 6px; }
    button { padding: 8px 14px; border: 0; background: #1967d2; color: #fff; border-radius: 6px; cursor: pointer; }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    small.note { color: gray; }
  </style>
</head>
<body>
  <h3>Google Gemini TTS 语音播放 Demo</h3>

  <div class="row">
    <label for="api-key">API Key（仅用于本地调试，不要提交到仓库）</label>
    <input id="api-key" type="password" placeholder="粘贴你的 Google API Key" />
  </div>

  <div class="row">
    <label for="tts-text">合成文本</label>
    <textarea id="tts-text" rows="3">用温暖友好的语气说：你好，欢迎来到语音合成演示！</textarea>
  </div>

  <div class="row">
    <button id="play-btn" onclick="playTTS()">播放语音</button>
  </div>

  <audio id="tts-audio" controls></audio>
  <p class="note">提示：浏览器直接请求 Google API 可能受 CORS 或 API Key 来源限制。如有问题，请使用本地服务器打开本页，或通过后端代理。</p>

  <script>
    const ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent';

    async function playTTS() {
      const apiKey = document.getElementById('api-key').value.trim();
      const text = document.getElementById('tts-text').value.trim();
      const btn = document.getElementById('play-btn');
      const audio = document.getElementById('tts-audio');

      if (!apiKey) { alert('请粘贴有效的 API Key'); return; }
      if (!text) { alert('请输入要合成的文本'); return; }

      btn.disabled = true; btn.textContent = '请求中...';
      try {
        const body = {
          contents: [ { parts: [ { text } ] } ],
          generationConfig: {
            responseModalities: [ 'AUDIO' ],
            speechConfig: {
              voiceConfig: {
                prebuiltVoiceConfig: { voiceName: 'Kore' }
              }
            }
          }
        };

        const resp = await fetch(ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-goog-api-key': apiKey
          },
          body: JSON.stringify(body)
        });

        if (!resp.ok) {
          const errText = await resp.text().catch(() => '');
          throw new Error(`请求失败: ${resp.status} ${resp.statusText} - ${errText}`);
        }

        const data = await resp.json();
        const { base64, mime } = extractAudioBase64(data);
        if (!base64) throw new Error('未在响应中找到音频数据');

        // 处理不同的音频类型
        const bytes = base64ToUint8Array(base64);
        let blob;
        if (mime && /wav/i.test(mime)) {
          blob = new Blob([bytes], { type: mime });
        } else {
          // 默认按 24kHz/单声道/16bit PCM 封装 WAV
          blob = createWAV(bytes, 24000, 1, 16);
        }

        const url = URL.createObjectURL(blob);
        audio.src = url;
        await audio.play();
      } catch (err) {
        console.error(err);
        alert(err.message || '播放失败');
      } finally {
        btn.disabled = false; btn.textContent = '播放语音';
      }
    }

    // 从 Gemini 返回结构中提取 base64 音频（兼容 inline_data/audio 等不同形态）
    function extractAudioBase64(payload) {
      // 常见结构：candidates[0].content.parts[0].inline_data.{ mime_type, data }
      const cand = payload?.candidates?.[0];
      const parts = cand?.content?.parts || [];

      for (const p of parts) {
        if (p?.inline_data?.data) {
          return { base64: p.inline_data.data, mime: p.inline_data.mime_type };
        }
        // 兼容可能的其他命名
        if (p?.inlineData?.data) {
          return { base64: p.inlineData.data, mime: p.inlineData.mimeType };
        }
        if (p?.audio?.data) {
          return { base64: p.audio.data, mime: p.audio.mime_type || p.audio.mimeType };
        }
      }
      return { base64: null, mime: null };
    }

    function base64ToUint8Array(b64) {
      // 处理 URL-safe base64
      const norm = b64.replace(/-/g, '+').replace(/_/g, '/');
      const bin = atob(norm);
      const len = bin.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
      return bytes;
    }

    // PCM to WAV 文件头封装
    function createWAV(pcmData, sampleRate, numChannels, bitDepth) {
      const blockAlign = numChannels * (bitDepth / 8);
      const byteRate = sampleRate * blockAlign;
      const dataSize = pcmData.length;
      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);

      // RIFF chunk descriptor
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeString(view, 8, 'WAVE');

      // fmt subchunk
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);          // Subchunk1Size (16 for PCM)
      view.setUint16(20, 1, true);           // AudioFormat (1 = PCM)
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);

      // data subchunk
      writeString(view, 36, 'data');
      view.setUint32(40, dataSize, true);

      // 写入 PCM 数据
      new Uint8Array(buffer, 44).set(pcmData);
      return new Blob([buffer], { type: 'audio/wav' });
    }

    function writeString(view, offset, str) {
      for (let i = 0; i < str.length; i++) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    }
  </script>
</body>
</html>
